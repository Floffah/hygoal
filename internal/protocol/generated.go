// Code generated by protogen. DO NOT EDIT.

package protocol

import (
	"encoding/binary"
	"fmt"

	"github.com/google/uuid"
)

type Packet interface {
	ID() uint32
}

type ClientType byte

const (
	GAME   ClientType = iota
	EDITOR ClientType = iota
)

type Connect struct {
	ProtocolHash   string
	ClientType     ClientType
	UUID           uuid.UUID
	Language       *string
	IdentityToken  *string
	Username       string
	ReferralData   *[]byte
	ReferralSource *HostAddress
}

func DecodeConnect(payload []byte) (Packet, error) {
	if len(payload) < 102 {
		return nil, fmt.Errorf("Connect payload too small: %d", len(payload))
	}

	var err error
	packet := &Connect{}

	// optional fields bitfield
	var nullBits byte = payload[0]

	// fixed fields

	// Field protocolHash

	protocolHashPos := 1

	protocolHashRaw := payload[protocolHashPos:64]
	protocolHash := string(protocolHashRaw)

	packet.ProtocolHash = protocolHash
	// Field clientType

	clientTypePos := 65

	clientType := payload[clientTypePos]
	packet.ClientType = ClientType(clientType)
	// Field UUID

	var UUID [16]byte

	UUIDPos := 66

	copy(UUID[:], payload[UUIDPos:UUIDPos+16])

	var UUIDSlice []byte = UUID[:]
	packet.UUID, err = uuid.FromBytes(UUIDSlice)
	if err != nil {
		return nil, fmt.Errorf("failed to parse UUID: %w", err)
	}
	// offsets
	languageOffset := int(int32(binary.LittleEndian.Uint32(payload[82:86])))
	identityTokenOffset := int(int32(binary.LittleEndian.Uint32(payload[86:90])))
	usernameOffset := int(int32(binary.LittleEndian.Uint32(payload[90:94])))
	referralDataOffset := int(int32(binary.LittleEndian.Uint32(payload[94:98])))
	referralSourceOffset := int(int32(binary.LittleEndian.Uint32(payload[98:102])))

	// variable-length fields
	if (nullBits & 0x01) != 0 {

		// Field language

		languagePos := 102 + languageOffset

		language, _, err := ReadVarString(payload, languagePos, 128, false)
		if err != nil {
			return nil, fmt.Errorf("error reading language: %v", err)
		}

		packet.Language = &language
	}

	if (nullBits & 0x02) != 0 {

		// Field identityToken

		identityTokenPos := 102 + identityTokenOffset

		identityToken, _, err := ReadVarString(payload, identityTokenPos, 8192, false)
		if err != nil {
			return nil, fmt.Errorf("error reading identityToken: %v", err)
		}

		packet.IdentityToken = &identityToken
	}

	// Field username

	usernamePos := 102 + usernameOffset

	username, _, err := ReadVarString(payload, usernamePos, 16, false)
	if err != nil {
		return nil, fmt.Errorf("error reading username: %v", err)
	}

	packet.Username = username
	if (nullBits & 0x04) != 0 {

		// Field referralData

		referralDataPos := 102 + referralDataOffset

		referralDataLen, referralDataLenSize, err := ReadVarInt(payload, referralDataPos)
		if err != nil {
			return nil, fmt.Errorf("error reading referralData length: %v", err)
		}

		if referralDataLen < 0 {

			return nil, fmt.Errorf("invalid referralData length: %d", referralDataLen)
		}

		if referralDataLen > 4096 {
			return nil, fmt.Errorf("referralData length too large: %d", referralDataLen)
		}

		referralDataStart := referralDataPos + referralDataLenSize
		referralDataEnd := referralDataStart + int(referralDataLen)
		if referralDataEnd > len(payload) {
			return nil, fmt.Errorf("referralData data exceeds payload length")
		}

		ReferralDataValue := make([]byte, referralDataLen)
		copy(ReferralDataValue, payload[referralDataStart:referralDataEnd])
		packet.ReferralData = &ReferralDataValue
	}

	if (nullBits & 0x08) != 0 {

		// Field referralSource

		referralSourcePos := 102 + referralSourceOffset

		referralSource, _, err := DecodeHostAddress(payload, referralSourcePos)
		if err != nil {
			return nil, fmt.Errorf("error decoding referralSource: %v", err)
		}
		packet.ReferralSource = &referralSource
	}

	return packet, nil
}
func (p *Connect) ID() uint32 {
	return 0
}

type HostAddress struct {
	Port     uint16
	Hostname string
}
